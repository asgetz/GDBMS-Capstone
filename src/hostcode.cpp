// kernel.cu
// Alex Getz




#include <fstream>
#include <boost/iostreams/stream.hpp>
#include <libs/iostreams/src/mapped_file.cpp>
#include <cuda.h>
#include <cuda_runtime.h>
#include <KernelInterface.h>
// #include <driver_types.h>
// #include "device_launch_parameters.h"

#include <algorithm>
#include <iostream>
#include <sstream>
#include <cstring>
#include <string>
#include <vector>
#include <random>
#include <time.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <array>
#include <assert.h>

#define MAX_ENTRIES 11897027

/**
 * [main description]
 * @method main
 * @param  int  [description]
 * @return      [description]
 */
int main(){

    /* Variables have been offloaded into the KernelInterface class within
     * kernel.h
     * Most are public and/or generated by the class constructor
     * So then create an opject to reference it by here.
     */
    //

    KernelInterface *obj;


    ////// Read in Population data and store it
    using boost::iostreams::mapped_file_source;
    using boost::iostreams::stream;
    mapped_file_source mmap("../data/allCountries.txt");
    stream<mapped_file_source> is(mmap, std::ios::binary);

    // int *pData_h;
    std::string line;

    // pData_h = (int*)malloc(MAX_ENTRIES*sizeof(int));

    uintmax_t m_numLines = 0;
    while (std::getline(is, line))
    {
        int counter=0;
        std::stringstream ss;
        std::string temp;
        // std::cout<<"\n"<<line<<"\n";
        ss << line;
        std::getline(ss,temp,'\t');
        // std::cout<<temp<<", position: "<<++counter<<"\n";
        while(std::getline(ss,temp,'\t')){
            if(temp.length() == 4){

                // Right now treat whole input stream as the sample
                // Later will add ability to distinguish what size of sample you want.
                // numEntries[i]=std::atoi(entries[i].c_str());
                // pData_h[m_numLines] = std::atoi(temp.c_str());
                obj->BaseSample[m_numLines] = std::atoi(temp.c_str());



                // std::cout<<temp<<", position: "<<++counter<<"\n";
                break;
            } else{ ++counter; }
        }
        m_numLines++;
        // if(m_numLines==5){ break; }
    }
    std::cout << "m_numLines = " << m_numLines << "\n";

    //////////////////// Copy to Device, launch, and copy back to host
    /* All of these steps have been offloaded onto the KernelInterface class */

    //////////////////// Statistical analysis ; WILL OFFLOAD
    /* At the very least calculate the pertinent bootstrap things
     * Maybe even go further with histograms and charts through nvvp or something
     */
    //



    //////////////////// Free veriables. Possibly invoke class deconstructor

    // printf("\n\n\nDONE\n\n\n");
    // free(pData_h);
    cudaFree(obj->d_Base);
    cudaFree(obj->randArray);
    cudaFreeHost(obj->BaseSample);
    return 0;
}


//////// Take a sample of 100 unique elements of population data
// int temp;
// int sumOriginal = 0;
// int meanOriginal;
// for(int i=0;i<SAMPLE_SIZE;++i){
//     int count=0;
//     do{
//         temp=PopRand();
//         //std::cout<<"i = "<<i<<" :  "<<temp<<std::endl;
//         ++count;
//     }while(std::any_of(sKey.begin(),sKey.end(),[&](int x){return x==temp;}));
//     sKey[i]=temp;
//     BaseSample[i]=pData[temp];
//     sumOriginal+=BaseSample[i];
//     /////////////// IF STATEMENT PRINTF TO CHECK IF THE OUTPUT IS CORRECT
//     //std::cout<<"BaseSample element "<<i<<" :  "<<BaseSample[i]<<" with key of "<<sKey[i]<<std::endl;
//     if(count>1){
//         printf("While loop pass count = ");
//         std::cout<<count<<" on element i = "<<i<<std::endl;
//     }
// }
// meanOriginal = sumOriginal/100;


//////////////////// Calculate Statistics. Soon to be offloaded
// int finalMean[400]={0};
// // std::vector<int> *meanVector;
// int bnum = 0;
// int sum1;
// int sum2 = 0;
// // int temp1;
// for (int a=0;a<400;++a){
//     sum1=0;
//     for(int b=0;b<100;++b){
//         sum1+=h_mean[b+(100*bnum)];
//     }
//     finalMean[a]=sum1/100;
//     // temp1 = sum1/100;
//     // meanVector[a].push_back( temp1 );
//     sum2 += std::pow( (finalMean[a]-meanOriginal), 2 );
//     bnum++;
//     // std::cout<<"Final Mean "<<a<<" : "<<finalMean[a]<<std::endl;
// }
// printf("\n\n\n");
// std::sort(finalMean,finalMean+SAMPLE_SIZE);
// std::cout<<"sum2 is "<<sum2<<std::endl;
// int div = 400;
// std::cout<<"div is "<<div<<std::endl;
// float stdDeviation = sqrt( (sum2/div) );
// std::cout<<"Standard Deviation is "<<stdDeviation<<std::endl;
// float stdErrorFactor = ( 100.0 / (100.0-1.0) );
// std::cout<<"The Error Factor is "<<stdErrorFactor<<std::endl;
// float stdError = sqrt( stdErrorFactor ) * stdDeviation;
// std::cout<<"Standard Error is "<<stdError<<std::endl;
// int tempA; int tempB;
// float lowerCI = 400 * ( 0.05/2 );
// tempA = finalMean[(int)lowerCI];
// std::cout<<"Lower (5%) Confidence Interval is "<<tempA<<std::endl;
// float higherCI = 400 * ( 1 - (0.05/2) );
// tempB = finalMean[(int)higherCI];
// std::cout<<"Higher (95%) Confidence Interval is "<<tempB<<std::endl;
//
// //////// Free data allocation from Device and Host
// cudaFree(d_Base);
// cudaFree(d_mean);
// cudaFreeHost(BaseSample);
// cudaFreeHost(h_mean);
