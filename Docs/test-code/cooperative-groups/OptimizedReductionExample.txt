


template <unsigned int blockSize>
__device__ void warpReduce(volatile int *sdata, unsigned int tid){
	if(blockSize>=64){ sdata[tid]+=sdata[tid+32]; }
	if(blockSize>=32){ sdata[tid]+=sdata[tid+16]; }
	if(blockSize>=16){ sdata[tid]+=sdata[tid+ 8]; }
	if(blockSize>= 8){ sdata[tid]+=sdata[tid+ 4]; }
	if(blockSize>= 4){ sdata[tid]+=sdata[tid+ 2]; }
	if(blockSize>= 2){ sdata[tid]+=sdata[tid+ 1]; }
}

template <unsigned int blockSize>
__global__ void reduce6(int *g_idata, int *g_odata, unsigned int n){
	extern __shared__ int sdata[];
	unsigned int tid 		= threadIdx.x;
	unsigned int i			= blockIdx.x*(blockSize*2) + tid;
	unsigned int gridSize	= blockSize*2*gridDim.x;
	sdata[tid] 				= 0;
	
	while(i<n){ sdata[tid] += g_idata[i] + g_idata[i+blockSize]; i+=gridSize; }
	__syncthreads();
	
	if(blockSize>=512){ if(tid<256){ sdata[tid]+=sdata[tid+256]; } __syncthreads(); }
	if(blockSize>=256){ if(tid<128){ sdata[tid]+=sdata[tid+128]; } __syncthreads(); }
	if(blockSize>=128){ if(tid< 64){ sdata[tid]+=sdata[tid+ 64]; } __syncthreads(); }
	
	if(tid<32){ warpReduce(sdata,tid); }
	if(tid==0){ g_odata[blockIdx.x]=sdata[0]; }
}

https://github.com/torch/cutorch/blob/master/lib/THC/THCTensorRandom.cuh
https://github.com/torch/cutorch/blob/master/lib/THC/THCTensorRandom.cu
https://github.com/torch/cutorch/blob/master/lib/THC/generic/THCTensorRandom.cu
https://github.com/torch/cutorch/blob/master/lib/THC/THCReduceApplyUtils.cu
https://github.com/torch/cutorch/blob/master/lib/THC/THCReduceApplyUtils.cuh


////////////////////////////////////////////////////////////////////////////////
/**
   Returns the current thread's warp ID
*/
__device__ __forceinline__ int getWarpId() {
  return (threadIdx.z * blockDim.y * blockDim.x +
          threadIdx.y * blockDim.x +
          threadIdx.x) / warpSize;
}

/**
   Return the current thread's lane in the warp
*/
__device__ __forceinline__ int getLaneId() {
  int laneId;
  asm("mov.s32 %0, %laneid;" : "=r"(laneId) );
  return laneId;
}
https://github.com/facebook/fbcuda/blob/master/CudaUtils.cuh



def choice(self, a, size=None, replace=True, p=None):
        """
        choice(a, size=None, replace=True, p=None)
        Generates a random sample from a given 1-D array
                .. versionadded:: 1.7.0
        Parameters
        ----------
        a : 1-D array-like or int
            If an ndarray, a random sample is generated from its elements.
            If an int, the random sample is generated as if a were np.arange(a)
        size : int or tuple of ints, optional
            Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
            ``m * n * k`` samples are drawn.  Default is None, in which case a
            single value is returned.
        replace : boolean, optional
            Whether the sample is with or without replacement
        p : 1-D array-like, optional
            The probabilities associated with each entry in a.
            If not given the sample assumes a uniform distribution over all
            entries in a.
        Returns
        -------
        samples : single item or ndarray
            The generated random samples
        Raises
        ------
        ValueError
            If a is an int and less than zero, if a or p are not 1-dimensional,
            if a is an array-like of size 0, if p is not a vector of
            probabilities, if a and p have different lengths, or if
            replace=False and the sample size is greater than the population
            size
        See Also
        --------
        randint, shuffle, permutation
        Examples
        --------
        Generate a uniform random sample from np.arange(5) of size 3:
        >>> np.random.choice(5, 3)
        array([0, 3, 4]) # random
        >>> #This is equivalent to np.random.randint(0,5,3)
        Generate a non-uniform random sample from np.arange(5) of size 3:
        >>> np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])
        array([3, 3, 0]) # random
        Generate a uniform random sample from np.arange(5) of size 3 without
        replacement:
        >>> np.random.choice(5, 3, replace=False)
        array([3,1,0]) # random
        >>> #This is equivalent to np.random.permutation(np.arange(5))[:3]
        Generate a non-uniform random sample from np.arange(5) of size
        3 without replacement:
        >>> np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])
        array([2, 3, 0]) # random
        Any of the above can be repeated with an arbitrary array-like
        instead of just integers. For instance:
        >>> aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']
        >>> np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])
        array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random
              dtype='<U11')
        """

	# Format and Verify input
	a = np.array(a, copy=False)
	if a.ndim == 0:
		try:
			# __index__ must return an integer by python rules.
			pop_size = operator.index(a.item())
		except TypeError:
			raise ValueError("'a' must be 1-dimensional or an integer")
		if pop_size <= 0 and np.prod(size) != 0:
			raise ValueError("'a' must be greater than 0 unless no samples are taken")
	elif a.ndim != 1:
		raise ValueError("'a' must be 1-dimensional")
	else:
		pop_size = a.shape[0]
		if pop_size is 0 and np.prod(size) != 0:
			raise ValueError("'a' cannot be empty unless no samples are taken")

	if p is not None:
		d = len(p)

		atol = np.sqrt(np.finfo(np.float64).eps)
		if isinstance(p, np.ndarray):
			if np.issubdtype(p.dtype, np.floating):
				atol = max(atol, np.sqrt(np.finfo(p.dtype).eps))

		p = <ndarray>PyArray_ContiguousFromObject(p, NPY_DOUBLE, 1, 1)
		pix = <double*>PyArray_DATA(p)

		if p.ndim != 1:
			raise ValueError("'p' must be 1-dimensional")
		if p.size != pop_size:
			raise ValueError("'a' and 'p' must have same size")
		p_sum = kahan_sum(pix, d)
		if np.isnan(p_sum):
			raise ValueError("probabilities contain NaN")
		if np.logical_or.reduce(p < 0):
			raise ValueError("probabilities are not non-negative")
		if abs(p_sum - 1.) > atol:
			raise ValueError("probabilities do not sum to 1")

	shape = size
	if shape is not None:
		size = np.prod(shape, dtype=np.intp)
	else:
		size = 1

	# Actual sampling
	if replace:
		if p is not None:
			cdf = p.cumsum()
			cdf /= cdf[-1]
			uniform_samples = self.random_sample(shape)
			idx = cdf.searchsorted(uniform_samples, side='right')
			idx = np.array(idx, copy=False) # searchsorted returns a scalar
		else:
			idx = self.randint(0, pop_size, size=shape)
	else:
		if size > pop_size:
			raise ValueError("Cannot take a larger sample than "
							 "population when 'replace=False'")

		if size < 0:
			raise ValueError("negative dimensions are not allowed")

		if p is not None:
			if np.count_nonzero(p > 0) < size:
				raise ValueError("Fewer non-zero entries in p than size")
			n_uniq = 0
			p = p.copy()
			found = np.zeros(shape, dtype=np.int)
			flat_found = found.ravel()
			while n_uniq < size:
				x = self.rand(size - n_uniq)
				if n_uniq > 0:
					p[flat_found[0:n_uniq]] = 0
				cdf = np.cumsum(p)
				cdf /= cdf[-1]
				new = cdf.searchsorted(x, side='right')
				_, unique_indices = np.unique(new, return_index=True)
				unique_indices.sort()
				new = new.take(unique_indices)
				flat_found[n_uniq:n_uniq + new.size] = new
				n_uniq += new.size
			idx = found
		else:
			idx = self.permutation(pop_size)[:size]
			if shape is not None:
				idx.shape = shape

	if shape is None and isinstance(idx, np.ndarray):
		# In most cases a scalar will have been made an array
		idx = idx.item(0)

	#Use samples as indices for a if a is array-like
	if a.ndim == 0:
		return idx

	if shape is not None and idx.ndim == 0:
		# If size == () then the user requested a 0-d array as opposed to
		# a scalar object when size is None. However a[idx] is always a
		# scalar and not an array. So this makes sure the result is an
		# array, taking into account that np.array(item) may not work
		# for object arrays.
		res = np.empty((), dtype=a.dtype)
		res[()] = a[idx]
		return res

return a[idx]

cdef object cont0_array(rk_state *state, rk_cont0 func, object size,
                        object lock):
    cdef double *array_data
    cdef ndarray array "arrayObject"
    cdef npy_intp length
    cdef npy_intp i

    if size is None:
        with lock, nogil:
            rv = func(state)
        return rv
    else:
        array = <ndarray>np.empty(size, np.float64)
        length = PyArray_SIZE(array)
        array_data = <double *>PyArray_DATA(array)
        with lock, nogil:
            for i from 0 <= i < length:
                array_data[i] = func(state)
return array

double
rk_double(rk_state *state)
{
    /* shifts : 67108864 = 0x4000000, 9007199254740992 = 0x20000000000000 */
    long a = rk_random(state) >> 5, b = rk_random(state) >> 6;
    return (a * 67108864.0 + b) / 9007199254740992.0;
}

#define RK_MAX 0xFFFFFFFFUL






$ nvcc -g -G -Xcompiler -Wall -lcudart -lcurand -c kernel.cu -o kernel.o

$ nvcc --gpu-architecture=sm_70 --device-link kernel.o --output-file link.o

$ nvcc --lib --output-file gpu.lib kernel.o link.o

$ g++ -g -Wall -std=c++11 -O3 -I. -I"D:\Boost\boost_1_69_0" 
-I"C:\PROGRA~1\NVIDIA~2\CUDA\v10.0\include" -c hostcode.cpp -o hostcode.o

$ g++ -g -Wall -std=c++11 -O3 -L"D:\git\GDBMS-Capstone\src" 
-L"C:\PROGRA~1\NVIDIA~2\CUDA\v10.0\lib\x64" -L"D:\Boost\boost_1_69_0\stage\lib" 
-lgpu -lcudart -lcudadevrt -lcurand 
-lboost_filesystem-mgw73-mt-d-x64-1_69 -lboost_iostreams-mgw73-mt-d-x64-1_69 
-lboost_system-mgw73-mt-d-x64-1_69 -o main hostcode.o





